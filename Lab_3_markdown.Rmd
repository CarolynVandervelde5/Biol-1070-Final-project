---
title: "Biol*4510 Final Project"
author: "Carolyn Vandervelde"
date: '2021-03-29'
output: html_document
---
Data from: Mendelsohn, B., Bedrosian, B., Love Stowell, S.M. et al. Population genomic diversity and structure at the discontinuous southern range of the Great Gray Owl in North America. Conserv Genet 21, 693–706 (2020). https://doi.org/10.1007/s10592-020-01280-8

## Summary
Species = Great Gray Owl
Sample sites = 5
Number of individuals = 123
SNPs = 4817
Environments the original authors interested in = discontinuous southern extent of the Great Gray Owl range in North America 
Range of values for popden = 0-255
K = 4 using the elbow method

```{r setup, include=TRUE, results='hide'}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=12, fig.height=8) 
setwd("/Users/carolynvandervelde/Desktop/UoM/Pop_gen/Final_project_owl")

library(usethis)
library(devtools)
library(adegenet)
library(ade4)
library(poppr) 
library(ape) 
library(tidyverse)
```

## Read in VCF and pop cood data file
There are 123 individuals sampled from 5 locations within the owls spring breeding range in the US 
```{r Read in VCF and pop cood data file, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
library(vcfR) 
# Read in VCF and pop cood data file
vcf.owl <- read.vcfR("variants_4817snps_123inds.vcf") #read in vcr
head(vcf.owl) #validate
queryMETA(vcf.owl) #summersising meta usefull for comprehension of the file’s contents.
pop.data <- read.table("owl_pop.txt", header = TRUE) #read in coordinate data
all(colnames(vcf.owl@gt) [-1] == pop.data$State) #check that all the samples in the VCF and the population data frame are included
```

## Convert to genlight for Population genetic analyses for GBS data
```{r Convert to genlight, message=FALSE, warning=FALSE, include=TRUE, paged.print=TRUE}
#convert to genlight
gl.owl <- vcfR2genlight(vcf.owl) 
ploidy(gl.owl) <- 2 #specify the ploidy of the organism
pop(gl.owl) <- pop.data$population #specify the population
gl.owl # genlight object
```

## Distance tree analysis
```{r Distance tree analysis, message=FALSE, warning=FALSE, include=TRUE}
library(RColorBrewer)
#Tree analysis
owl.dist <- poppr::bitwise.dist(gl.owl, missing_match = TRUE, scale_missing = TRUE) #distance matrix
tree <- aboot(gl.owl, tree = "upgma", distance = bitwise.dist, sample = 100, showtree = F, cutoff = 50, quiet = T)
cols <- brewer.pal(n = nPop(gl.owl), name = "Set3")
plot.phylo(tree, cex = 0.8, font = 2, adj = 0, tip.color = 
             cols[pop(gl.owl)])
nodelabels(tree$node.label, adj = c(1.3, -0.5), frame = "n", cex = 0.8,font = 
             3, xpd = TRUE) 
legend('topleft', legend = c("CA","WY","ID", "ORN", "ORS"), fill = cols, border = FALSE,
       bty = "n", cex = 2)
axis(side = 1)
title(xlab = "Genetic distance (proportion of loci that are different)")
```

## PCA
Choosing to look at PC 1, 2, and 3 becuse the eignvalue drops off after 3, although there is a high difference between PC 1 and the rest. 

WY and ID group together on all axies (consistant with paper) even though the paper removed potentialy related individuals from analysis. 
```{r PCA}
library(RColorBrewer)
owl.pca <- glPca(gl.owl, nf = 3) 
barplot(100*owl.pca$eig/sum(owl.pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2) 
title(xlab="Eigenvalues", line = 1)

owl.pca.scores <- as.data.frame(owl.pca$scores) 
owl.pca.scores$pop <- pop(gl.owl) #add the population values as a new column 
cols <- brewer.pal(n = nPop(gl.owl), name = "Set3")

library(ggplot2)
set.seed(9)
p1v2 <- ggplot(owl.pca.scores, aes(x=PC1, y=PC2, colour=pop)) +
  geom_point(size=2) +
  stat_ellipse(level = 0.95, size = 1) +
  scale_color_manual(values = cols) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  theme_bw()
p1v2

p1v3 <- ggplot(owl.pca.scores, aes(x=PC1, y=PC3, colour=pop)) +
  geom_point(size=2) +
  stat_ellipse(level = 0.95, size = 1) +
  scale_color_manual(values = cols) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  theme_bw()
p1v3

p2v3 <- ggplot(owl.pca.scores, aes(x=PC2, y=PC3, colour=pop)) +
  geom_point(size=2) +
  stat_ellipse(level = 0.95, size = 1) +
  scale_color_manual(values = cols) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  theme_bw()
p2v3
```

## Choosing K for admixture analysis and lfmm
"best" k from the AIC appears to be 4 (same as paper) using the elbow method
```{r AIC, message=FALSE, include=TRUE}
##choose 'k'
gen.owl <- vcfR2genind(vcf.owl, sep = "[|/]", return.alleles = TRUE) #convert vcf to genind for AIC
#AIC
owl.aic <- snapclust.choose.k(max = 10, gen.owl)
plot(1:10, owl.aic, xlab = "Number of clusters (k)",
     ylab = "AIC", type = "b", pch = 20, cex = 3)
```

## Convert to LFMM
```{r lfmm}
library(LEA)
owl.lfmm <- vcf2lfmm("/Users/carolynvandervelde/Desktop/UoM/Pop_gen/Final_project_owl/variants_4817snps_123inds.vcf", output.file = "/Users/carolynvandervelde/Desktop/UoM/Pop_gen/Final_project_owl/variants_4817snps_123inds.lfmm", force = TRUE)
owl.lfmm <- read.lfmm("variants_4817snps_123inds.lfmm")
```

## Non-spacial admixture analysis
Elbow of k value graph is at k=3 the package help page says that the "best" k is the next to the right of the elbow so k=4 in this case
```{r Non-spacial admixture analysis, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
library(LEA)
library(maps)

write.geno(owl.lfmm, "/Users/carolynvandervelde/Desktop/UoM/Pop_gen/Final_project_owl/owl.geno") #convert lfmm to geno file
owl.geno <- read.geno("owl.geno") #read geno file into r sesion
impute("owl.snmfProject","owl.lfmm", method = "random", K=4, run=best) #remove NA values 

project = snmf("/Users/carolynvandervelde/Desktop/UoM/Pop_gen/Final_project_owl/owl.geno",
               K = 1:10,
               entropy = TRUE,
               repetitions = 10,
               project = "new")
plot(project, col = "blueviolet", pch = 19, cex = 1.2) #plot best K value graph using project defined with above function (4)

#plot with K=4
best = which.min(cross.entropy(project, K = 4))
barchart(project, K = 4, run = best,
         border = NA, space = 0,
         col = cols,
         xlab = "Individuals",
         ylab = "Ancestry proportions",
         main = "Ancestry matrix (K = 4)") -> bp
axis(1, at = 1:length(bp$order),
     labels = bp$order, las=1,
     cex.axis = .4)
#plot with K=3
best = which.min(cross.entropy(project, K = 3))
barchart(project, K = 3, run = best,
         border = NA, space = 0,
         col = cols,
         xlab = "Individuals",
         ylab = "Ancestry proportions",
         main = "Ancestry matrix (K = 3)") -> bp
axis(1, at = 1:length(bp$order),
     labels = bp$order, las=1,
     cex.axis = .4)
#plot with K=5
best = which.min(cross.entropy(project, K = 5))
barchart(project, K = 5, run = best,
         border = NA, space = 0,
         col = cols,
         xlab = "Individuals",
         ylab = "Ancestry proportions",
         main = "Ancestry matrix (K = 5)") -> bp
axis(1, at = 1:length(bp$order),
     labels = bp$order, las=1,
     cex.axis = .4)
```

## Spatial admixture
I was suprised to see that the spacial and non spacial bar plots actualy structure quite simmilarly looking at where the individuals fall. The spacial data does sugest that that higer proportions of the genone is from the dominant population where with the non-spacial there are many more individuals with high overlap
```{r Spatial admixture, message=FALSE, warning=FALSE, include=TRUE}
library(tess3r)
library(maps)
library(rworldmap)
library(raster)
library(rgdal)
library(sp)
owl_just_coords <- as.matrix(read.table("owl_just_coords.txt", header = FALSE)) #two-column file ignore headers
owl.lfmm.withNA <- replace(owl.lfmm, owl.lfmm == 9, NA) #change matrix value of 9 (=missing data) to NA because tess3 wants encoded as NA

genotype = owl.lfmm.withNA #matrix format corresponds to the .lfmm format 
coordinates = owl_just_coords #V1 needs to be long V2 needs to be lat for subsequent steps to work
asc.raster="http://membres-timc.imag.fr/Olivier.Francois/RasterMaps/North_America.asc" #raster file for mapping
plot(coordinates, pch = 19, cex = .5, xlab = "Longitude (°E)", ylab = "Latitude (°N)") #plot map with coordinates on it 
map(add = T, interior = F)
tess3.obj <- tess3(X = genotype, coord = coordinates, K = 1:8, XProba = NULL,
                   method = "projected.ls", ploidy = 2, openMP.core.num = 4) #estimating ansestry co-effiencents
plot(tess3.obj, pch = 19, col = "blue",
     xlab = "Number of ancestral populations",
     ylab = "Cross-validation score")  # plot function generates a plot for root mean-squared errors

# retrieve tess3 Q matrix for K = 5 clusters 
q.matrix5 <- qmatrix(tess3.obj, K = 5)
# STRUCTURE-like barplot for the Q-matrix5 
barplot(q.matrix5, border = NA, space = 0, 
        xlab = "Individuals", ylab = "Ancestry proportions", 
        main = "Ancestry matrix (K = 5)") -> bp
axis(1, at = 1:nrow(q.matrix5), labels = bp$order, las = 3, cex.axis = .4) 
#plot Q matrix on geographic map
owl.space.plot <- plot(q.matrix5, coordinates, method = "map.max", cex = .4,  
     interpol = FieldsKrigModel(10), 
     background = TRUE,
     raster.filename = asc.raster,
     map.polygon = NULL,
     main = "Ancestry coefficients (K=5)",
     xlab = "Longitude", ylab = "Latitude", 
     col.palette = cols)

# retrieve tess3 Q matrix for K = 4 clusters 
q.matrix4 <- qmatrix(tess3.obj, K = 4)
# STRUCTURE-like barplot for the Q-matrix4
barplot(q.matrix4, border = NA, space = 0, 
        xlab = "Individuals", ylab = "Ancestry proportions", 
        main = "Ancestry matrix (K = 4)") -> bp
axis(1, at = 1:nrow(q.matrix4), labels = bp$order, las = 3, cex.axis = .4) 
#plot Q matrix on geographic map 
owl.space.plot <- plot(q.matrix4, coordinates, method = "map.max", cex = .4,  
                       interpol = FieldsKrigModel(10), 
                       background = TRUE,
                       raster.filename = asc.raster,
                       map.polygon = NULL,
                       main = "Ancestry coefficients (K=4)",
                       xlab = "Longitude", ylab = "Latitude", 
                       col.palette = cols)
              
# retrieve tess3 Q matrix for K = 3 clusters 
q.matrix3 <- qmatrix(tess3.obj, K = 3)
# STRUCTURE-like barplot for the Q-matrix3 
barplot(q.matrix3, border = NA, space = 0, 
        xlab = "Individuals", ylab = "Ancestry proportions", 
        main = "Ancestry matrix (K = 3)") -> bp
axis(1, at = 1:nrow(q.matrix3), labels = bp$order, las = 3, cex.axis = .4) 
#plot Q matrix on geographic map
owl.space.plot <- plot(q.matrix3, coordinates, method = "map.max", cex = .4,  
                       interpol = FieldsKrigModel(10), 
                       background = TRUE,
                       raster.filename = asc.raster,
                       map.polygon = NULL,
                       main = "Ancestry coefficients (K=3)",
                       xlab = "Longitude", ylab = "Latitude", 
                       col.palette = cols)

```

## Hum pop density map
```{r Hum pop density map, message=FALSE, warning=FALSE}
#spacial plots
library(raster)
library(sp)
library(sf)
library(rgeos)
library(rgdal)
#'sites' is where you will put your coordinates. You should be able to add your file name 
# (saved as a .csv file) and run all of this code. 'popden' will be the same for everyone
sites <- read.csv("owl.coord.csv", header = TRUE)
pop_den <- raster("SEDAC_POP_2000-01-01_gs_360x180.tiff")
## Making sites a spatial object:
# I tend to make a copy first, because once you make it spatial you can't easily manipulate the original dataframe
sites_sp <- sites
# set coordinate system
sites_sp <- sf::st_as_sf(sites, coords = c("Long", "Lat"), crs = 4326)
st_crs(sites_sp)
st_crs(pop_den)
# Here we want to reproject into an equal area projection so when we buffer points, distances are measured in meters (not decimal degrees)
AEA <- "+proj=aea +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
sites_AEA <- st_transform(sites_sp, AEA)
## you can check to see they're transformed by looking at the coordinates
head(st_coordinates(sites_AEA))
st_crs(sites_AEA)$units
sites_buff <- st_buffer(sites_AEA, byid = TRUE, dist = 10000)
ex <- raster::extract(pop_den, sites_buff, fun=mean, na.rm=TRUE, df=TRUE) # this is a dataframe (no longer spatial)
#this should be good to go for lfmm!!
pop_den.env <- ex[,2]
```

## Manhatan plot
```{r Manhatan plot, include=TRUE}
## Fit and LFMM, i.e, compute B, U, V estimates
library(lfmm)
df_envs <- pop_den.env
df_geno <- read.table("variants_4817snps_123inds.lfmm")
lfmm_mod <- lfmm_ridge(Y = df_geno,
                       X = df_envs,
                       K = 4)
## Perform association testing using the fitted model:
pv <- lfmm_test(Y = owl.lfmm,
                X = df_envs,
                lfmm = lfmm_mod,
                calibrate = "gif")
pvalues <- pv$calibrated.pvalue
qqplot(rexp(length(pvalues), rate = log(10)), -log10(pvalues), xlab = "Expected quantile",
       pch = 19, cex = .4) 
abline(0,1)
plot(-log10(pvalues),
     pch = 19,
     cex = .3,
     xlab = "Probe", ylab = "-Log P",
     col = "grey")
pred <- predict_lfmm(Y = df_geno,
                     X = df_envs,
                     fdr.level = 0.25,
                     lfmm_mod)
# Manhattan plot with the Polygenic Risk Scores are computed.
plot(-log10(pv$calibrated.pvalue),
     pch = 19,
     cex = .3,
     xlab = "Probe", ylab = "-Log P",
     col = "grey")
causal.set <- pred$candidates
points(causal.set,
       -log10(pv$calibrated.pvalue)[causal.set], col = "blue")

#manhatan plot with 0.10 PRC
pred2 <- predict_lfmm(Y = df_geno, X = df_envs, fdr.level = 0.10, lfmm_mod) #Polygenic Risk Scores
plot(-log10(pv$calibrated.pvalue), pch = 19, cex = .3, xlab = "Probe", ylab = "-Log P", col = "grey")
causal.set2 <- pred2$candidates
points(causal.set2, -log10(pv$calibrated.pvalue)[causal.set2], col = "blue")

#manhatan plot with 0.01 PRC
pred3 <- predict_lfmm(Y = df_geno, X = df_envs, fdr.level = 0.01, lfmm_mod) #Polygenic Risk Scores
plot(-log10(pv$calibrated.pvalue), pch = 19, cex = .3, xlab = "Probe", ylab = "-Log P", col = "grey")
causal.set3 <- pred3$candidates
points(causal.set3, -log10(pv$calibrated.pvalue)[causal.set3], col = "blue")

```

## Hardy Weinberg Equilibrium
```{r Hardy Weinberg Equilibrium, message=FALSE, warning=FALSE, include=TRUE}
#HWE
library(adegenet)
library(pegas)
gen.owl <- vcfR2genind(vcf.owl, sep = "[|/]", return.alleles = TRUE) #convert to genind
pop(gen.owl) <- pop.data$population #specify the population for genind object
#parse data into each populations 
owl.pop.ORN <- gen.owl[gen.owl$pop == "ORN"]
owl.pop.ID <- gen.owl[gen.owl$pop == "ID"]
owl.pop.ORS <- gen.owl[gen.owl$pop == "ORS"]
owl.pop.CA <- gen.owl[gen.owl$pop == "CA"]
owl.pop.WY <- gen.owl[gen.owl$pop == "WY"]
#pegas package test of HWE using genind data
HWE.owl <- hw.test(gen.owl)  #for all populations
summary(HWE.owl)
HWE.owl.pop.ORN <- hw.test(owl.pop.ORN) #for ORN population
summary(HWE.owl.pop.ORN)
HWE.owl.pop.ID <- hw.test(owl.pop.ID) #for ID population
summary(HWE.owl.pop.ID)
HWE.owl.pop.ORS <- hw.test(owl.pop.ORS) #for ORS population
summary(HWE.owl.pop.ORS)
HWE.owl.pop.CA <- hw.test(owl.pop.CA) #for CA population
summary(HWE.owl.pop.CA)
HWE.owl.pop.WY <- hw.test(owl.pop.WY) #for WY population
summary(HWE.owl.pop.WY)
```

##Evluating effective population size
Ne outputs a file that cant be read into r because its not in that format so ill attach it
```{r effective population size, message=FALSE, include=TRUE}
#Ne
library(RLDNe)
library(hierfstat)
gen.owl <- vcfR2genind(vcf.owl, sep = "[|/]", return.alleles = TRUE) #convert to genind
pop(gen.owl) <- pop.data$population #specify the population for genind object
owl.loci <- genind2hierfstat(gen.owl) #NeV2_LDNe_create require data frame of type hierfstat

write_genepop_zlr(loci = owl.loci, pops = pop.data$population, ind.ids = pop.data$idcode,
                  folder = getwd(), filename="/owl_genpop.txt",
                  missingVal = NA, ncode = 2, diploid = T)

#mating system of 0 = random mating, default is manogamy, 
#name of infile is differnt than write_genepop_zlr function becuse light editing of the popgen file was required
param_files <- NeV2_LDNe_create(input_file = "owl_genpop2.txt", param_file = "Ne_params.txt", 
                                  NE_out_file = "Ne_out.txt", matingsystem = 0)
run_LDNe(LDNe_params = param_files$param_file)
Ne_estimates <- (path = param_files$Ne_out_tab)
```

##Ho, He, Fis, Fst 
Low fst indicateds that the different populations dont have a high degree of differentiation. Ho is also not considerable differnt between the popualtions. 
```{r, include=TRUE}
library(hierfstat)
library(pegas)
gen.owl <- vcfR2genind(vcf.owl, sep = "[|/]", return.alleles = TRUE) #convert to genind
pop(gen.owl) <- pop.data$population #specify the population for genind object
owl.loci <- genind2hierfstat(gen.owl) #data frame of type hierfstat
#parse data into each populations 
owl.loci.ORN <- gen.owl[owl.loci$pop == "ORN"]
owl.loci.ID <- gen.owl[owl.loci$pop == "ID"]
owl.loci.ORS <- gen.owl[owl.loci$pop == "ORS"]
owl.loci.CA <- gen.owl[owl.loci$pop == "CA"]
owl.loci.WY <- gen.owl[owl.loci$pop == "WY"]
#basic stats for each population
higherfstat.owl <- basic.stats(owl.loci, diploid = TRUE) #Basic stats for all populations
print(higherfstat.owl$overall)
higherfstat.owl.ORN <- basic.stats(owl.loci.ORN, diploid = TRUE) #Basic stats population ORN
print(higherfstat.owl.ORN$overall)
higherfstat.owl.ID <- basic.stats(owl.loci.ID, diploid = TRUE) #Basic stats population ID
print(higherfstat.owl.ID$overall)
higherfstat.owl.ORS <- basic.stats(owl.loci.ORS, diploid = TRUE) #Basic stats population ORS
print(higherfstat.owl.ORS$overall)
higherfstat.owl.CA <- basic.stats(owl.loci.CA, diploid = TRUE) #Basic stats population CA
print(higherfstat.owl.CA$overall)
higherfstat.owl.WY <- basic.stats(owl.loci.WY, diploid = TRUE) #Basic stats population WY
print(higherfstat.owl.WY$overall)

#obserevd vs exspected heterozygosity plot in the adegenet package
owl.het <- summary(gen.owl)
owl.het
plot(owl.het$Hobs,owl.het$Hexp, xlab="Hobs", ylab="Hexp", 
     main="Expected heterozygosity as a function of observed heterozygosity")
```

##Fst
```{r Fst}
#Pairwise Fst using weir and cockerham fst in hierfstat
pairwise.WCfst(owl.loci, diploid = TRUE)

#population specific fst
betas(gen.owl,nboot=0, lim=c(0.025,0.975), diploid=TRUE, betaijT=FALSE)
```
